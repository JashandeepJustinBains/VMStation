All code is run on the masternode 192.168.4.63 is running debian bookworm, it has SSH keys on all machines so it can communicate with them. This is the monitoring node that also runs the dashboards and ingests logs and metrics from the other nodes and pods.
The masternode is the control-plane node.
the storagenodet3500 192.168.4.61 is running debian bookworm the SAMBA server and runs the jellyfin node. Currently this node is only used to stream jellyfin to my families devices. We should avoid any unnecesary pods on this device to ensure optimum bandwidth and computation for streaming.
the homelab 192.168.4.62 is the compute node that is running RHEL10 and currently has the least pods on it. I will eventually add pods that I will use for my homelab. In fact you can come up with some ideas. It will also eventually be my lab for testing VM interconnectivity for praciticng with job interviews.
Then names in the inventory filee have been updated to inventory/group_vars/hosts.yml



I eventually want the coredns node to service all physically connected links while my IPS's modem and router can service wireless connections. but currently the ansible deployment is very unstable due to bad practices and incorrect playbooks.

The kube-proxy and kube-flannel and all other necessary backbone pods should be operating correctly upon deployment and not needing stupid scripts post deployment to attempt to fix it.

I need this to be a clean setup so that i can learn best practices and spin up and spin down whenever I need to maintain cost effectivness. For example there should be a hourly batch process that happens on the masternode that checks to see if the resources are being utilized currently (such as users logged into jellyfin or not) and if they are not it should begin the process of spinning down and sleeping all nodes while ensureing they can be awoken on LAN using magic packets. The masternode is a minipc and uses the least amount of energy so I am fine ensuring 100% uptime on that machine, especially since it contians the coredns node that will be neecessary for wireless devices. I can eventually add in enterprise grade security systems and frameworks to play with as well. 
I also plan to implement other strong netwwork security such as rotating TLS certificates, network wide password managment, 

This is my ansible version. If you think I should upgrade go ahead and do it wherever you see it necessary.
ansible [core 2.14.18]
  config file = None
  configured module search path = ['/root/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/lib/python3/dist-packages/ansible
  ansible collection location = /root/.ansible/collections:/usr/share/ansible/collections
  executable location = /usr/bin/ansible
  python version = 3.11.2 (main, Apr 28 2025, 14:11:48) [GCC 12.2.0] (/usr/bin/python3)
  jinja version = 3.1.2
  libyaml = True

This is my kubectl version, again upgrade anything wherever you see fit as long as it maintains oeprational
Client Version: v1.34.0
Kustomize Version: v5.7.1
Server Version: v1.29.15
Warning: version difference between client (1.34) and server (1.29) exceeds the supported minor version skew of +/-1


The ansible playbooks must be gold-standard 100% robustness with never-fail idempotent setup. That is 
I should be able to do 'deploy.sh' -> 'deploy.sh reset' -> 'deploy.sh' 100 times in a row with no failures. Do not begin until u understand the nuances between RHEL 10 (NFTABLES BACKEND) and Debian Bookworm (IPTABLES BACKEND)
Thee playbooks should bee short and concise with no errors on any run/deployment.
All the Main and deploy-cluster playbooks are corrupted or wrong. Ensure they are short concise but do exactly what is neded of them
Do not put oveerly long timeouts it just leads to longer wait times for errors to appear, however I am certain you can accomplish this task the first time without errors.

