# --- Robust Pre-checks for CNI/Flannel Deployment ---
- name: Pre-check required kernel modules
  become: true
  ansible.builtin.shell: |
    missing=0
    for mod in br_netfilter overlay nf_conntrack vxlan; do
      lsmod | grep -q $mod || missing=1
    done
    exit $missing
  register: kernel_mod_check
  failed_when: kernel_mod_check.rc != 0
  changed_when: false

- name: Pre-check sysctl settings for Kubernetes CNI
  become: true
  ansible.builtin.shell: |
    sysctl -n net.bridge.bridge-nf-call-iptables | grep -q '^1$' && \
    sysctl -n net.bridge.bridge-nf-call-ip6tables | grep -q '^1$' && \
    sysctl -n net.ipv4.ip_forward | grep -q '^1$'
  register: sysctl_check
  failed_when: sysctl_check.rc != 0
  changed_when: false

- name: Pre-check node readiness (all nodes must be Ready)
  become: true
  ansible.builtin.shell: |
    kubectl get nodes --no-headers | awk '{print $2}' | grep -v '^Ready$' && exit 1 || exit 0
  register: node_ready_check
  failed_when: node_ready_check.rc != 0
  changed_when: false

# --- Standardize CNI interface name to 'cni' ---
# (This should be reflected in Flannel manifest and CNI config templates)
# If any CNI config or manifest uses 'cbr', replace with 'cni' (idempotent)
- name: Standardize CNI interface name to 'cni' in CNI configs
  become: true
  ansible.builtin.shell: |
    find /etc/cni/net.d -type f -exec sed -i 's/\"cbr\"/\"cni\"/g' {} +
#  ignore_errors: true
# Ensure kernel modules, sysctl and basic forwarding rules required for Kubernetes CNI

- name: Install required network packages (RHEL/CentOS)
  become: true
  ansible.builtin.package:
    name:
      - iptables
      - iptables-services
      - conntrack-tools
      - socat
      - iproute-tc
    state: present
  when: ansible_os_family == 'RedHat'
  ignore_errors: true

- name: Install required network packages (Debian/Ubuntu)
  become: true
  ansible.builtin.package:
    name:
      - iptables
      - conntrack
      - socat
      - iproute2
    state: present
  when: ansible_os_family == 'Debian'
  ignore_errors: true

- name: Load all required kernel modules
  become: true
  ansible.builtin.command:
    cmd: "modprobe {{ item }}"
  loop:
    - br_netfilter
    - overlay
    - nf_conntrack
    - vxlan
  changed_when: false
  ignore_errors: true

- name: Persist all required kernel modules on boot
  become: true
  ansible.builtin.copy:
    dest: /etc/modules-load.d/kubernetes.conf
    content: |
      # Kubernetes required modules
      br_netfilter
      overlay
      nf_conntrack
      vxlan
    owner: root
    group: root
    mode: '0644'
  notify: restart kubelet

- name: Ensure sysctl settings for Kubernetes CNIs
  become: true
  ansible.builtin.copy:
    dest: /etc/sysctl.d/99-k8s.conf
    content: |
      net.bridge.bridge-nf-call-iptables = 1
      net.bridge.bridge-nf-call-ip6tables = 1
      net.ipv4.ip_forward = 1
    owner: root
    group: root
    mode: '0644'
  notify: restart kubelet

- name: Apply sysctl settings
  become: true
  ansible.builtin.command:
    cmd: sysctl --system
  changed_when: false

- name: Ensure ip_forward is enabled at runtime
  become: true
  ansible.builtin.sysctl:
    name: net.ipv4.ip_forward
    value: '1'
    state: present

- name: Try to set iptables FORWARD policy to ACCEPT (best-effort)
  become: true
  ansible.builtin.command:
    cmd: iptables -P FORWARD ACCEPT
  ignore_errors: true

- name: If ufw exists, disable it to avoid blocking pod traffic (best-effort)
  become: true
  ansible.builtin.stat:
    path: /usr/sbin/ufw
  register: ufw_path

- name: Stop and disable ufw when present
  become: true
  ansible.builtin.service:
    name: ufw
    state: stopped
    enabled: false
  when: ufw_path.stat.exists
  ignore_errors: true

- name: Stop and disable firewalld on RHEL systems (Flannel VXLAN requires open communication)
  become: true
  ansible.builtin.service:
    name: firewalld
    state: stopped
    enabled: false
  when: ansible_os_family == 'RedHat'
  ignore_errors: true

- name: Ensure NetworkManager conf.d directory exists
  become: true
  ansible.builtin.file:
    path: /etc/NetworkManager/conf.d
    state: directory
    owner: root
    group: root
    mode: '0755'
  when: ansible_service_mgr == 'systemd'
  ignore_errors: true

- name: Configure NetworkManager to ignore CNI interfaces (RHEL/Debian)
  become: true
  ansible.builtin.copy:
    dest: /etc/NetworkManager/conf.d/99-kubernetes.conf
    content: |
      [keyfile]
      unmanaged-devices=interface-name:cni*;interface-name:flannel*;interface-name:veth*
    owner: root
    group: root
    mode: '0644'
  notify: restart NetworkManager
  when: ansible_service_mgr == 'systemd'
  ignore_errors: true

- name: Configure iptables-legacy as default on RHEL systems (kube-proxy compatibility)
  become: true
  ansible.builtin.command:
    cmd: "{{ item }}"
  loop:
    - alternatives --set iptables /usr/sbin/iptables-legacy
    - alternatives --set ip6tables /usr/sbin/ip6tables-legacy
  when: ansible_os_family == 'RedHat'
  ignore_errors: true
  changed_when: false

- name: Set SELinux to permissive mode on RHEL (temporary for CNI compatibility)
  become: true
  ansible.posix.selinux:
    policy: targeted
    state: permissive
  when: ansible_os_family == 'RedHat'
  ignore_errors: true

- name: Ensure SELinux permissive persists on reboot (RHEL)
  become: true
  ansible.builtin.lineinfile:
    path: /etc/selinux/config
    regexp: '^SELINUX='
    line: 'SELINUX=permissive'
    state: present
  when: ansible_os_family == 'RedHat'
  ignore_errors: true

# kubelet will be restarted via handler 'restart kubelet' only when changes occur

# Ensure /etc/cni/net.d exists and is writable by root (required for Flannel CNI bootstrap)
# Ensure /etc/cni/net.d exists and is writable by root (required for Flannel CNI bootstrap)
- name: Ensure /etc/cni/net.d exists with correct permissions (CNI bootstrap)
  become: true
  ansible.builtin.file:
    path: /etc/cni/net.d
    state: directory
    owner: root
    group: root
    mode: '0755'
  ignore_errors: true

# Ensure /etc/cni/net.d exists and is writable by root (required for Flannel CNI bootstrap)
- name: Ensure /etc/cni/net.d exists with correct permissions (CNI bootstrap)
  become: true
  ansible.builtin.file:
    path: /etc/cni/net.d
    state: directory
    owner: root
    group: root
    mode: '0755'
  ignore_errors: false

# Remove any conflicting CNI configs before Flannel deploy (idempotent)
- name: Remove conflicting CNI configs before Flannel deploy
  become: true
  ansible.builtin.find:
    paths: /etc/cni/net.d
    patterns: '*'
    excludes: '10-flannel.conflist'
    file_type: file
  register: cni_conflicting_files

- name: Delete conflicting CNI configs
  become: true
  ansible.builtin.file:
    path: "{{ item.path }}"
    state: absent
  loop: "{{ cni_conflicting_files.files }}"
  when: cni_conflicting_files.matched > 0

# Validate that Flannel CNI config is present after deploy (fail early if missing)
- name: Check for Flannel CNI config after deploy
  become: true
  ansible.builtin.stat:
    path: /etc/cni/net.d/10-flannel.conflist
  register: flannel_cni_conf

- name: Fail if Flannel CNI config is missing (critical for pod networking)
  ansible.builtin.fail:
    msg: "Flannel CNI config /etc/cni/net.d/10-flannel.conflist is missing after deploy. Pod networking will not function. Check Flannel DaemonSet logs."
  when: not flannel_cni_conf.stat.exists
