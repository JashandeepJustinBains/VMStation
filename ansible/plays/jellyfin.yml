---
# Jellyfin Deployment Playbook
# Deploys Jellyfin using the minimal Kubernetes manifest
- hosts: storage_nodes
  gather_facts: false
  connection: local
  vars:
    jellyfin_manifest_path: "kubernetes/jellyfin-minimal.yml"
  tasks:
    - name: Skip Jellyfin deployment if disabled
      ansible.builtin.meta: end_play
      when: not (jellyfin_enabled | default(true) | bool)

    - name: Check if kubectl is available
      ansible.builtin.shell:
        cmd: command -v kubectl
      register: kubectl_check
      failed_when: false
      changed_when: false
      check_mode: false

    - name: Show kubectl path and client version when present
      block:
        - name: Display kubectl path
          ansible.builtin.debug:
            msg: "kubectl found at: {{ kubectl_check.stdout | default('') }}"

        - name: Show kubectl client version
          ansible.builtin.command:
            cmd: "{{ kubectl_check.stdout }} version --client"
          register: kubectl_version
          failed_when: false
          changed_when: false
        - ansible.builtin.debug:
            var: kubectl_version.stdout_lines
      when: kubectl_check.rc == 0

    - name: Fail with remediation if kubectl not available
      ansible.builtin.fail:
        msg: |
          kubectl is required for Jellyfin deployment. Install it with:
          
          For Ubuntu/Debian:
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          
          For RHEL/CentOS/Fedora:
          sudo dnf install -y kubectl
      when: kubectl_check.rc != 0

    - name: Check if target node exists in cluster
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Node
        name: "{{ jellyfin_node_name | default('storagenodet3500') }}"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: target_node_check
      failed_when: false

    - name: Get all available nodes if target not found
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Node
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: cluster_info
      when: target_node_check.resources is not defined or not target_node_check.resources

    - name: Set jellyfin deployment node
      set_fact:
        actual_jellyfin_node: "{{ jellyfin_node_name | default('storagenodet3500') }}"
      when: target_node_check.resources is defined and target_node_check.resources

    - name: Fallback to available storage nodes if target not found
      set_fact:
        actual_jellyfin_node: "{{ cluster_info.resources | selectattr('metadata.labels.storage_nodes', 'defined') | map(attribute='metadata.name') | first | default(cluster_info.resources[0].metadata.name) }}"
      when: (target_node_check.resources is not defined or not target_node_check.resources) and (cluster_info.resources is defined and cluster_info.resources)

    - name: Display node availability status
      debug:
        msg: |
          Target node status for Jellyfin deployment:
          Requested node: {{ jellyfin_node_name | default('storagenodet3500') }}
          Actual deployment node: {{ actual_jellyfin_node | default('ERROR: No nodes available') }}
          Node exists: {{ 'Yes' if target_node_check.resources else 'No - using fallback' }}
          {% if not target_node_check.resources and cluster_info.resources %}
          
          Available nodes:
          {% for node in cluster_info.resources %}
          - {{ node.metadata.name }} ({{ node.status.addresses[0].address | default('No IP') }})
          {% endfor %}
          {% endif %}

    - name: Get cluster nodes for reference
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Node
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: cluster_info
      when: not target_node_check.resources

    - name: Clean up any existing Jellyfin resources to prevent conflicts
      kubernetes.core.k8s:
        kubeconfig: /etc/kubernetes/admin.conf
        validate_certs: false
        state: absent
        api_version: "{{ item.api_version }}"
        kind: "{{ item.kind }}"
        name: "{{ item.name }}"
        namespace: "{{ item.namespace | default(omit) }}"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      loop:
        - { api_version: "v1", kind: "Service", name: "jellyfin-service", namespace: "jellyfin" }
        - { api_version: "v1", kind: "Service", name: "jellyfin", namespace: "jellyfin" }
        - { api_version: "apps/v1", kind: "Deployment", name: "jellyfin", namespace: "jellyfin" }
        - { api_version: "v1", kind: "Pod", name: "jellyfin", namespace: "jellyfin" }
        - { api_version: "v1", kind: "PersistentVolumeClaim", name: "jellyfin-config-pvc", namespace: "jellyfin" }
        - { api_version: "v1", kind: "PersistentVolumeClaim", name: "jellyfin-media-pvc", namespace: "jellyfin" }
        - { api_version: "v1", kind: "PersistentVolume", name: "jellyfin-config-pv" }
        - { api_version: "v1", kind: "PersistentVolume", name: "jellyfin-media-pv" }
      ignore_errors: true

    - name: Deploy Jellyfin namespace
      kubernetes.core.k8s:
        kubeconfig: /etc/kubernetes/admin.conf
        validate_certs: false
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: jellyfin
            labels:
              name: jellyfin
              app: jellyfin
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf

    - name: Deploy Jellyfin pod
      kubernetes.core.k8s:
        kubeconfig: /etc/kubernetes/admin.conf
        validate_certs: false
        state: present
        definition:
          apiVersion: v1
          kind: Pod
          metadata:
            name: jellyfin
            namespace: jellyfin
            labels:
              app: jellyfin
              component: media-server
          spec:
            nodeSelector:
              kubernetes.io/hostname: "{{ actual_jellyfin_node | default(jellyfin_node_name | default('storagenodet3500')) }}"
            securityContext:
              runAsUser: 1000
              runAsGroup: 1000
              fsGroup: 1000
            containers:
            - name: jellyfin
              image: jellyfin/jellyfin:latest
              imagePullPolicy: IfNotPresent
              ports:
              - name: http
                containerPort: 8096
                protocol: TCP
              - name: https
                containerPort: 8920
                protocol: TCP
              env:
              - name: JELLYFIN_PublishedServerUrl
                value: "http://{{ groups['storage_nodes'][0] | default('192.168.4.61') }}:30096"
              # Health check configuration
              - name: HEALTHCHECK_URL
                value: "http://localhost:8096/health"
              resources:
                requests:
                  memory: "512Mi"
                  cpu: "200m"
                limits:
                  memory: "2Gi"
                  cpu: "1000m"
              volumeMounts:
              - name: media
                mountPath: /media
                readOnly: true
              - name: config
                mountPath: /config
                readOnly: false
              livenessProbe:
                httpGet:
                  path: /health
                  port: 8096
                  scheme: HTTP
                initialDelaySeconds: 180
                periodSeconds: 60
                timeoutSeconds: 30
                failureThreshold: 5
              readinessProbe:
                httpGet:
                  path: /health
                  port: 8096
                  scheme: HTTP
                initialDelaySeconds: 120
                periodSeconds: 30
                timeoutSeconds: 15
                failureThreshold: 5
              startupProbe:
                httpGet:
                  path: /health
                  port: 8096
                  scheme: HTTP
                initialDelaySeconds: 60
                periodSeconds: 15
                timeoutSeconds: 10
                failureThreshold: 30
              securityContext:
                allowPrivilegeEscalation: false
                readOnlyRootFilesystem: false
                capabilities:
                  drop:
                  - ALL
            volumes:
            - name: media
              hostPath:
                path: "{{ jellyfin_media_path | default('/srv/media') }}"
                type: DirectoryOrCreate
            - name: config
              hostPath:
                path: "{{ jellyfin_config_path | default('/var/lib/jellyfin') }}"
                type: DirectoryOrCreate
            restartPolicy: Always
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf

    - name: Deploy Jellyfin service
      kubernetes.core.k8s:
        kubeconfig: /etc/kubernetes/admin.conf
        validate_certs: false
        state: present
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: jellyfin-service
            namespace: jellyfin
            labels:
              app: jellyfin
              component: media-server
          spec:
            type: NodePort
            selector:
              app: jellyfin
              component: media-server
            ports:
            - name: http
              port: 8096
              targetPort: 8096
              nodePort: 30096
              protocol: TCP
            - name: https
              port: 8920
              targetPort: 8920
              nodePort: 30920
              protocol: TCP
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf

    - name: Get Jellyfin pod status
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Pod
        name: jellyfin
        namespace: jellyfin
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: jellyfin_pod_info
      failed_when: false

    - name: Get Jellyfin service info
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Service
        name: jellyfin-service
        namespace: jellyfin
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: jellyfin_service_info
      failed_when: false

    - name: "Wait for Jellyfin pod to be ready (with improved error handling)"
      block:
        - name: "Check if storage node is ready before deploying Jellyfin"
          kubernetes.core.k8s_info:
            api_version: v1
            kind: Node
            name: "{{ actual_jellyfin_node | default(jellyfin_node_name | default('storagenodet3500')) }}"
          environment:
            KUBECONFIG: /etc/kubernetes/admin.conf
          register: storage_node_ready
          
        - name: "Verify storage node is in Ready state"
          fail:
            msg: "Target storage node {{ actual_jellyfin_node | default(jellyfin_node_name | default('storagenodet3500')) }} is not Ready. Node status: {{ storage_node_ready.resources[0].status.conditions | selectattr('type', 'equalto', 'Ready') | map(attribute='status') | first | default('Unknown') }}"
          when: 
            - storage_node_ready.resources | length == 0 or
              (storage_node_ready.resources[0].status.conditions | selectattr('type', 'equalto', 'Ready') | selectattr('status', 'equalto', 'True') | list | length == 0)
              
        - name: "Wait for Jellyfin pod to be ready"
          kubernetes.core.k8s_info:
            api_version: v1
            kind: Pod
            name: jellyfin
            namespace: jellyfin
            wait: true
            wait_condition:
              type: Ready
              status: "True"
            wait_timeout: "{{ jellyfin_readiness_timeout | default(300) }}"  # Reduced default timeout
          environment:
            KUBECONFIG: /etc/kubernetes/admin.conf
          register: jellyfin_ready_check
          ignore_errors: yes

    - name: Get updated Jellyfin pod status after wait
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Pod
        name: jellyfin
        namespace: jellyfin
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: jellyfin_final_status
      when: jellyfin_ready_check.failed | default(false)

    - name: Report Jellyfin deployment status
      ansible.builtin.debug:
        msg: |
          === Jellyfin Deployment Status ===
          Pod Status: {{ jellyfin_pod_info.resources[0].status.phase | default('Unknown') if jellyfin_pod_info.resources else 'Not Found' }}
          Service Port: {{ jellyfin_service_info.resources[0].spec.ports[0].nodePort | default('N/A') if jellyfin_service_info.resources else 'N/A' }}
          
          {% if jellyfin_pod_info.resources and jellyfin_pod_info.resources[0].status.phase == 'Running' %}
          ✅ Jellyfin is ready!
          Access at: http://{{ actual_jellyfin_node | default(jellyfin_node_name | default('storagenodet3500')) }}:{{ jellyfin_service_info.resources[0].spec.ports[0].nodePort | default('30096') }}
          {% elif jellyfin_ready_check.failed | default(false) and jellyfin_final_status.resources %}
          ❌ Jellyfin deployment has issues:
          Pod Status: {{ jellyfin_final_status.resources[0].status.phase | default('Unknown') }}
          {% if jellyfin_final_status.resources[0].status.containerStatuses is defined %}
          Container Status:
          {% for container in jellyfin_final_status.resources[0].status.containerStatuses %}
          - {{ container.name }}: {{ container.state.keys() | first }}
          {% if container.state.waiting is defined %}
            Reason: {{ container.state.waiting.reason | default('Unknown') }}
            Message: {{ container.state.waiting.message | default('') }}
          {% endif %}
          {% endfor %}
          {% endif %}
          
          Troubleshooting commands:
          - kubectl describe pod -n jellyfin jellyfin
          - kubectl logs -n jellyfin jellyfin
          {% else %}
          ⏳ Jellyfin is still starting up. Check status with:
          kubectl get pods -n jellyfin
          {% endif %}

    - name: Set facts for site.yaml validation
      ansible.builtin.set_fact:
        jellyfin_pod_ready: "{{ jellyfin_pod_info.resources[0].status.phase == 'Running' if jellyfin_pod_info.resources else false }}"
        jellyfin_service_nodeport: "{{ jellyfin_service_info.resources[0].spec.ports[0].nodePort | default('30096') if jellyfin_service_info.resources else '30096' }}"